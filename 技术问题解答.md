# 技术问题解答

## 1. 防抖实现怎么实现的，及其作用

### 实现原理
使用 `setTimeout` 延迟执行，每次触发时先清除旧定时器，再设置新定时器。

```typescript
let autoSaveTimer: number | null = null
const handleContentChange = () => {
  clearTimeout(autoSaveTimer)
  autoSaveTimer = setTimeout(() => {
    if (isModified.value) autoSave()
  }, 2000)
}
```

### 作用
- 减少请求次数：用户连续输入只发送一次保存请求
- 提升性能：降低服务器压力，减少网络开销
- 优化体验：避免频繁操作导致的界面卡顿

---

## 2. 如果已经保存的话，会不会一直发送保存请求

### 答案：不会

通过 `isModified` 状态标志和内容比对机制避免重复保存。

### 防重复机制
```typescript
// 1. 检查是否修改
const modified = editor.value.getHTML() !== documentData.value?.content

// 2. 只有修改时才保存
if (isModified.value) {
  autoSave()
}

// 3. 保存后重置状态
isModified.value = false
documentData.value.content = content
```

保存后更新原始内容引用，下次比对时内容相同则不触发保存。

---

## 3. Keep-Alive 的原理和作用（在项目中）

### 原理
Vue 内置组件，将组件实例缓存到内存而不是销毁，切换时直接从缓存恢复。

```vue
<keep-alive>
  <component :is="Component" :key="route.params.id" />
</keep-alive>
```

### 作用
1. **保持状态**：编辑内容、光标位置、滚动位置等完整保留
2. **提升性能**：避免重复创建组件，减少网络请求，标签页切换无延迟
3. **多标签支持**：每个文档独立缓存，可同时打开多个文档并快速切换

### 生命周期
```typescript
// 普通组件：created → mounted → unmounted
// keep-alive组件：created → mounted → deactivated → activated
```

---

**文档创建时间：** 2025年10月28日
